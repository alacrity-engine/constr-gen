package main

import (
	"flag"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"strings"
	"unicode"

	"github.com/golang-collections/collections/queue"
)

var (
	modulePath string
	gomodPath  string
	importBase string
)

// parseFlags parses the command line
// arguments passed as flag values.
func parseFlags() {
	flag.StringVar(&modulePath, "module",
		"./module", "Module to generate constructors for")
	flag.StringVar(&gomodPath, "gomod", ".",
		"Go module the game module is related to")

	flag.Parse()
}

// getImportBase obtains the Go module
// part of the game module package path for
// writing imports in the autogenerated file.
func getImportBase() {
	origWD, err := os.Getwd()
	handleError(err)
	err = os.Chdir(gomodPath)
	handleError(err)
	gomodDir, err := os.Getwd()
	handleError(err)
	err = os.Chdir(origWD)
	handleError(err)
	err = os.Chdir(modulePath)
	handleError(err)
	moduleDir, err := os.Getwd()
	handleError(err)
	err = os.Chdir(origWD)
	handleError(err)

	gomodPath := path.Dir(gomodDir)
	importBase = strings.TrimPrefix(moduleDir, gomodPath+"/")
}

func main() {
	parseFlags()
	getImportBase()

	// Create a string builder
	// for writing the generated
	// source code.
	sourceBuilder := new(strings.Builder)
	_, err := sourceBuilder.WriteString("package main\n")
	handleError(err)
	_, err = sourceBuilder.WriteString("\nimport \"github.com/alacrity-engine/core/ecs\"\n")

	// Get all the files and directories of the module.
	entries, err := ioutil.ReadDir(modulePath)
	handleError(err)
	traverseQueue := queue.New()

	// Enqueue them for breadth-first traversal.
	for _, entry := range entries {
		tracker := FileTracker{
			dir:  modulePath,
			info: entry,
		}

		traverseQueue.Enqueue(tracker)
	}

	// Collect all the package names
	// to write imports.
	packages := map[string]struct{}{}
	// Store all the type declarations
	// that are Alacrity components.
	comps := []TypeDeclaration{}

	for traverseQueue.Len() > 0 {
		entry := traverseQueue.Dequeue().(FileTracker)

		// If the entry is a directory.
		if entry.info.IsDir() {
			// Read the directory for entries.
			dirName := path.Join(entry.dir, entry.info.Name())
			entries, err = ioutil.ReadDir(dirName)
			handleError(err)

			// Enqueue them for breadth-first traversal.
			for _, entry := range entries {
				tracker := FileTracker{
					dir:  dirName,
					info: entry,
				}

				traverseQueue.Enqueue(tracker)
			}

			continue
		}

		// Analyze the source code file
		// using Go AST tools to find all
		// the type declarations.
		fileName := path.Join(entry.dir, entry.info.Name())
		fset := token.NewFileSet()
		file, err := parser.ParseFile(fset, fileName,
			nil, parser.ParseComments)
		handleError(err)

		typeDecls := []TypeDeclaration{}
		packageName := file.Name.Name
		packages[packageName] = struct{}{}

		ast.Inspect(file, func(n ast.Node) bool {
			switch t := n.(type) {
			// Find the type declaration.
			case *ast.GenDecl:
				for _, spec := range t.Specs {
					switch tt := spec.(type) {
					case *ast.TypeSpec:
						// Read the type name.
						typeName := tt.Name.Name

						switch ttt := tt.Type.(type) {
						case *ast.StructType:
							// Read the list of type fields.
							fieldList := ttt.Fields.List
							typeDecl := TypeDeclaration{
								packageName: packageName,
								typeName:    typeName,
								fieldList:   fieldList,
							}

							typeDecls = append(typeDecls, typeDecl)
						}
					}
				}
			}

			return true
		})

		// Select only the types that are components.
		for _, typeDecl := range typeDecls {
			// Find the "ecs.BaseComponent".
			for _, field := range typeDecl.fieldList {
				t, ok := field.Type.(*ast.SelectorExpr)

				if !ok {
					continue
				}

				x, ok := t.X.(*ast.Ident)

				if !ok {
					continue
				}

				if t.Sel.Name == "BaseComponent" && x.Name == "ecs" {
					comps = append(comps, typeDecl)
					break
				}
			}
		}
	}

	// Write the package imports
	// to the source builder.
	for packageName := range packages {
		if packageName == "main" {
			continue
		}

		importStr := "import \"" + path.Join(importBase,
			packageName) + "\"\n"

		_, err = sourceBuilder.WriteString(importStr)
		handleError(err)
	}

	// Generate constructors for all the
	// components found in the source file.
	for _, comp := range comps {
		funcSource := "\nfunc New_" + comp.packageName + "_" + comp.typeName +
			"(name string, params map[string]interface{}) ecs.Component" + "{\n"
		funcSource += "\tcomp := &" + comp.packageName + "." + comp.typeName + "{\n"

		for _, field := range comp.fieldList {
			// If the field is unnamed, skip it.
			if len(field.Names) <= 0 {
				continue
			}

			// Assume the type of the field.
			var paramTypeName string

			switch t := field.Type.(type) {
			// If it's a simple identifier (such as int, float64, etc.).
			case *ast.Ident:
				paramTypeName = t.Name

			// If it's an array.
			case *ast.ArrayType:
				switch tt := t.Elt.(type) {
				case *ast.Ident:
					paramTypeName = "[]" + tt.Name

				case *ast.SelectorExpr:
					x, ok := tt.X.(*ast.Ident)

					if !ok {
						continue
					}

					paramTypeName = "[]" + x.Name +
						"." + tt.Sel.Name

				default:
					continue
				}

			// If it'a map (aka key-value dictionary).
			case *ast.MapType:
				// Assume the type of map key.
				var keyType string

				switch tt := t.Key.(type) {
				case *ast.Ident:
					keyType = tt.Name

				case *ast.SelectorExpr:
					x, ok := tt.X.(*ast.Ident)

					if !ok {
						continue
					}

					keyType = x.Name + "." + tt.Sel.Name
				}

				// Assume the type of map value.
				var valueType string

				switch tt := t.Value.(type) {
				case *ast.Ident:
					valueType = tt.Name

				case *ast.SelectorExpr:
					x, ok := tt.X.(*ast.Ident)

					if !ok {
						continue
					}

					valueType = x.Name + "." + tt.Sel.Name
				}

				paramTypeName = "map[" + keyType + "]" + valueType

			// If it's a structure from some package
			// (such as time.Duration or pixel.Vec).
			case *ast.SelectorExpr:
				x, ok := t.X.(*ast.Ident)

				if !ok {
					continue
				}

				paramTypeName = x.Name + "." + t.Sel.Name

			default:
				continue
			}

			paramName := field.Names[0].Name

			// If the field is not public, skip it.
			if !unicode.IsUpper([]rune(paramName)[0]) {
				continue
			}

			funcSource += "\t\t" + paramName + ": params[\"" +
				paramName + "\"].(" + paramTypeName + "),\n"
		}

		funcSource += "\t}\n\n\tcomp.SetName(name)\n\n\treturn comp\n}\n"
		_, err = sourceBuilder.WriteString(funcSource)
		handleError(err)
	}

	// Write the source file to the
	// main package of the module.
	autogenFilePath := path.Join(modulePath, "autogenerated.go")
	autogenFile, err := os.OpenFile(autogenFilePath,
		os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
	handleError(err)

	_, err = autogenFile.WriteString(sourceBuilder.String())
	handleError(err)
	err = autogenFile.Close()
	handleError(err)

	// Add missing imports using 'goimports'.
	editedSource, err := exec.Command("goimports",
		autogenFilePath).Output()
	handleError(err)

	// Write the edited source to the autogenerated file.
	autogenFile, err = os.OpenFile(autogenFilePath,
		os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
	handleError(err)
	defer autogenFile.Close()

	_, err = autogenFile.WriteString(string(editedSource))
	handleError(err)
}

func handleError(err error) {
	if err != nil {
		panic(err)
	}
}
