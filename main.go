package main

import (
	_ "embed"
	"flag"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/golang-collections/collections/queue"
)

// TODO: sometimes a component requires
// a slice or a map of objects. I think
// they may be served in a prefab as
// []interface{} or map[interface{}]interface{}.
// I think I need to habdle such cases
// separately in field setters. I think
// I need to create a list() function for
// Lua scripts to pass arrays to the Go
// code as []interface{} instead of
// map[interface{}]interface{}.

var (
	gomodPath   string
	importBase  string
	gomodPrefix string

	//go:embed scene-component.go.tmpl
	sceneComponentTmpl string
	//go:embed scene-registry.go.tmpl
	sceneRegistryTmpl string
)

// parseFlags parses the command line
// arguments passed as flag values.
func parseFlags() {
	flag.StringVar(&gomodPath, "gomod", "/home/zergon321/go/src/test-game",
		"Go module the game module is related to")

	flag.Parse()
}

// getImportBase obtains the Go module
// part of the game module package path for
// writing imports in the autogenerated file.
func getImportBase() {
	origWD, err := os.Getwd()
	handleError(err)
	err = os.Chdir(gomodPath)
	handleError(err)
	gomodDir, err := os.Getwd()
	handleError(err)
	err = os.Chdir(origWD)
	handleError(err)

	// Make paths absolute.
	gomodPath, err = filepath.Abs(gomodPath)
	handleError(err)

	gomodPath := path.Dir(gomodDir)
	importBase = strings.TrimPrefix(gomodDir, gomodPath+"/")
	gomodPrefix = gomodPath
}

func main() {
	parseFlags()
	getImportBase()

	// Get all the files and directories of the module.
	entries, err := os.ReadDir(gomodPath)
	handleError(err)
	traverseQueue := queue.New()

	// Enqueue them for breadth-first traversal.
	for _, entry := range entries {
		tracker := FileTracker{
			dir:  gomodPath,
			info: entry,
		}

		traverseQueue.Enqueue(tracker)
	}

	// Store all the type declarations
	// that are Iris components.
	comps := []ComponentData{}

	for traverseQueue.Len() > 0 {
		entry := traverseQueue.Dequeue().(FileTracker)

		// If the entry is a directory.
		if entry.info.IsDir() {
			// Read the directory for entries.
			dirName := path.Join(entry.dir, entry.info.Name())
			entries, err = os.ReadDir(dirName)
			handleError(err)

			// Enqueue them for breadth-first traversal.
			for _, entry := range entries {
				tracker := FileTracker{
					dir:  dirName,
					info: entry,
				}

				traverseQueue.Enqueue(tracker)
			}

			continue
		}

		if !strings.HasSuffix(entry.info.Name(), ".go") {
			continue
		}

		// Analyze the source code file
		// using Go AST tools to find all
		// the type declarations.
		fileName := path.Join(entry.dir, entry.info.Name())
		fset := token.NewFileSet()
		file, err := parser.ParseFile(fset, fileName,
			nil, parser.ParseComments)
		handleError(err)
		imports := getImportSet(file)
		compPkg := strings.TrimPrefix(entry.dir, gomodPrefix+"/")
		typeDecls, err := findComponents(file)
		handleError(err)

		for i := 0; i < len(typeDecls); i++ {
			typeDecls[i].PkgPath = compPkg
			typeDecls[i].Imports = imports
		}

		comps = append(comps, typeDecls...)
	}

	// Generate template data.
	compPkgs := getCompPkgSet(comps)
	// Write the source files to the
	// main package of the module.
	compTemplate := template.New("scene-component.go.tmpl")
	_, err = compTemplate.Funcs(templateFuncs).
		Parse(sceneComponentTmpl)
	handleError(err)

	for _, comp := range comps {
		fpath := path.Join(
			gomodPrefix, comp.PkgPath,
			"autogen."+comp.Name+".go")
		file, err := os.Create(fpath)
		handleError(err)

		err = compTemplate.Execute(file, map[string]interface{}{
			"moduleRootPath":    importBase,
			"pkgPath":           comp.PkgPath,
			"componentTypeName": comp.Name,
			"fields":            comp.Fields,
			"imports":           comp.Imports,
		})
		handleError(err)

		err = file.Close()
		handleError(err)

		// Add missing imports using 'goimports'.
		editedSource, err := exec.Command("goimports", fpath).Output()
		handleError(err)
		// Write the edited source to the autogenerated file.
		file, err = os.OpenFile(fpath,
			os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
		handleError(err)
		_, err = file.WriteString(string(editedSource))
		handleError(err)

		err = file.Close()
		handleError(err)
	}

	regTemplate := template.New("scene-registry.go.tmpl")
	_, err = regTemplate.Funcs(templateFuncs).
		Parse(sceneRegistryTmpl)
	handleError(err)

	fpath := path.Join(gomodPath, "registry.go")
	file, err := os.Create(fpath)
	handleError(err)

	err = regTemplate.Execute(file, map[string]interface{}{
		"moduleRootPath": importBase,
		"compTypes":      comps,
		"pkgImports":     compPkgs,
	})
	handleError(err)

	err = file.Close()
	handleError(err)

	// Add missing imports using 'goimports'.
	editedSource, err := exec.Command("goimports", fpath).Output()
	handleError(err)
	// Write the edited source to the autogenerated file.
	file, err = os.OpenFile(fpath,
		os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
	handleError(err)
	_, err = file.WriteString(string(editedSource))
	handleError(err)

	err = file.Close()
	handleError(err)
}

func handleError(err error) {
	if err != nil {
		panic(err)
	}
}
